"""
AUTHOR: E Karvelis (karvels2@mit.edu)
PURPOSE:
Helper functions and classes for the dl_kcat repo
"""

# Import dependencies
import pandas as pd
import tempfile
import matplotlib.pyplot as plt
import seaborn as sns
import os
from glob import glob


class LogFile():
    """
    Given the output_text file filename (str) generated by transformer_1.py, 
    this class parses the file and contains functions to plot model performance 
    during training. Typical usage to plot RMSE across batches and epochs:
    log = LogFile('transformer_1_output.txt')
    log.plot_summary()
    """
    
    def __init__(self, filename, figname=False):
        # INPUT
        # filename -- name of output_text file. str
        # figname -- name of file to save output figure to
        self.task = 'kcat regression' # default task if unspecified in config file
        self.filename = filename
        self.config = glob(f'{os.path.dirname(os.path.abspath(self.filename))}/*config*')[0]
        with open(self.config, 'r') as f:
            settings = f.read()
        if 'NR/R binary classification' in settings:
            self.task = 'NR/R binary classification'
        elif 'kcat regression' in settings:
            self.task = 'kcat regression'

        if self.task == 'kcat regression':
            self.epoch_cols = ['Epoch', 'CV fold', 'Time', 'Val. loss', 'RMSE']
            self.batch_cols = ['Epoch', 'CV fold', 'Batch', 'Learning rate', 'Time/batch', 'Loss (MSE)', 'RMSE']
        elif self.task == 'NR/R binary classification':
            self.epoch_cols = ['Epoch', 'CV fold', 'Time', 'Val. loss', 'Acc.']
            self.batch_cols = ['Epoch', 'CV fold', 'Batch', 'Learning rate', 'Time/batch', 'Loss', 'sqrt(loss)', 'Acc.']

        self.figname = figname
        
        batches, epochs = [], []
        with open(self.filename, 'r') as f:
            
            for line in f:
                if len(line.rsplit()) == 0: continue
                if line.rsplit()[0] == 'epoch':
                    batches.append(line)
                elif line.rsplit()[0] == 'End':
                    epochs.append(line)
        
        # store epochs log in DataFrame
        tmp = tempfile.TemporaryFile(mode='w+t')
        tmp.writelines(epochs)
        tmp.seek(0)
        self.epochs = self.clean_epoch_table(pd.read_csv(tmp, sep='|', names=self.epoch_cols))
        tmp.close()
        
        # store batches log in DataFrame
        tmp = tempfile.TemporaryFile(mode='w+t')
        tmp.writelines(batches)
        tmp.seek(0)
        self.batches = self.clean_batch_table(pd.read_csv(tmp, sep='|', names=self.batch_cols))
        tmp.close()
    
    def clean_epoch_table(self, epochs):
        
        epochs['Epoch'] = [x.replace('End of epoch ','') for x in epochs['Epoch']]
        epochs['CV fold'] = [x.split('fold ')[-1].split('/')[0] for x in epochs['CV fold']]
        epochs['Time'] = [x.split('time ')[-1].split('s')[0] for x in epochs['Time']]

        if self.task == 'kcat regression':
            epochs['Val. loss'] = [x.split('MSE) ')[-1] for x in epochs['Val. loss']]
            epochs['RMSE'] = [x.split('RMSE ')[-1].split('s')[0] for x in epochs['RMSE']]
        elif self.task == 'NR/R binary classification':
            epochs['Val. loss'] = [x.split('valid loss ')[-1] for x in epochs['Val. loss']]
            epochs['Acc.'] = [x.split('accuracy ')[-1] for x in epochs['Acc.']]
        
        return epochs.apply(pd.to_numeric)
    
    def clean_batch_table(self, batches):
        
        batches['Epoch'] = [x.replace('epoch ','') for x in batches['Epoch']]
        batches['CV fold'] = [x.split('fold ')[-1].split('/')[0] for x in batches['CV fold']]
        batches['Batch'] = [x.split('/')[0] for x in batches['Batch']]
        batches['Learning rate'] = [x.split('lr ')[-1] for x in batches['Learning rate']]
        batches['Time/batch'] = [x.split('batch ')[-1] for x in batches['Time/batch']]

        if self.task == 'kcat regression':
            batches['Loss (MSE)'] = [x.split('loss ')[-1] for x in batches['Loss (MSE)']]
            batches['RMSE'] = [x.split('loss) ')[-1] for x in batches['RMSE']]
        elif self.task == 'NR/R binary classification':
            batches['Loss'] = [x.split('loss ')[-1] for x in batches['Loss']]
            batches['sqrt(loss)'] = [x.split('loss) ')[-1] for x in batches['sqrt(loss)']]
            batches['Acc.'] = [x.split('acc ')[-1] for x in batches['Acc.']]

        return batches.apply(pd.to_numeric)
        
    def plot_batches(self, ax=None):
        if self.task == 'kcat regression':
            ax = sns.lineplot(data=self.batches, x='Batch', y='RMSE', hue='Epoch', palette='flare', ax=ax)
            ax.set_ylabel('RMSE (train)', fontsize=20)
        elif self.task == 'NR/R binary classification':
            ax = sns.lineplot(data=self.batches, x='Batch', y='Acc.', hue='Epoch', palette='flare', ax=ax)
            ax.set_ylabel('Accuracy (train)', fontsize=20) 

        ax.set_xlabel('Batch', fontsize=20)
        ax.tick_params(axis='both', labelsize=18)
        return ax
        
    def plot_epochs(self, ax=None):
        if self.task == 'kcat regression':
            ax = sns.lineplot(data=self.epochs, x='Epoch', y='RMSE', hue='CV fold', palette='flare', ax=ax)
            ax.set_ylabel('RMSE (validation)', fontsize=20)
        elif self.task == 'NR/R binary classification':
            ax = sns.lineplot(data=self.epochs, x='Epoch', y='Acc.', hue='CV fold', palette='flare', ax=ax)
            ax.set_ylabel('Accuracy (validation)', fontsize=20)

        ax.set_xlabel('Epoch', fontsize=20)
        ax.tick_params(axis='both', labelsize=18)
        return ax

    def plot_summary(self):
        fig, axes = plt.subplots(3,1,figsize=(6,15))
        axes.flatten()[0] = self.plot_batches(ax=axes.flatten()[0])
        axes.flatten()[1] = self.plot_batches(ax=axes.flatten()[1])
        if self.task == 'kcat regression':
            axes.flatten()[1].set_ylim((0,2))
        elif self.task == 'NR/R binary classification':
            axes.flatten()[1].set_ylim((0.98,1))
        axes.flatten()[2] = self.plot_epochs(ax=axes.flatten()[2])
        fig.tight_layout()
        if self.figname:
            fig.savefig(self.figname, dpi=300)
        plt.show()
        return fig, axes